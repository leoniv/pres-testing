= Автоматизированное тестирование "Физический уровень"
Leonid Vlasov

== Вступление

> Автор не является специалистом в области тестирования ПО и не знает всех
академических терминов и определений этой области. Данный материал является
взглядом на тестирование со стороны программиста, т.е. того человека который
составляет *физический* текст программы. Данный материал основан на знаниях
полученных в процессе самостоятельного изучения данной темы по не
"академическим" источникам, исследовании чужого опыта на примере исходных
текстов и личном опыте составления тестов для платформ
Ruby и 1С:Предприятие.

<<<

> Под автоматизированным тестированием, в контексте этого документа,
следует понимать процесс тестирования ПО с помощью набора программ - тестов
которые выполняются, *исключительно*, без участия человека. Участие человека
допустимо лишь при запуске процесса тестирования.

<<<

В литературе встречаются три вида тестов которые я бы отнес к *"Физическому"*
уровню тестирования.

- *Модульные (Unit) тесты* - тестируется абсолютно изолированный код
- *Интеграционные тесты* - тестируется код в окружении близком к рабочему
- *Тесты интерфейса пользователя* - если тестируется интерфейс командной строки
тогда его можно полностью покрыть авто-тестами но если тестируется графический
интерфейс то можно тестировать только ту часть которая касается низкого уровня
реализации интерфейса. На пример тестирование кода обработчиков,
наличие и значения свойств виджетов (статика), значения виджетов (динамика).

Часто нет *возможности* или *необходимости* проведения четких границы между этими
видами тестов.

*Возможность* определяется ограничениями программной платформы, а
*необходимость* здравым смыслом.

На самом деле все достаточно индивидуально.

== Цель и возможности

*Цель тестирования* - пройти всеми закоулками кода (графа управления). Другими
словами необходимо создать тесты для каждого метода и вызвать этот метод со
всеми возможными вариантами его аргументов и условий в операторах ветвления и
цикла. На сколько достижима такая цель это уже отдельный вопрос.

*Что можно выяснить в результате?* - исключительно, "физическую"
работоспособность программы и "физический" результат её выполнения, но это уже
не мало и наверное составляет самый значимый кусок во всей системе тестирования.
Проверка прочих аспектов не входит в зону данного уровня
тестирования.

*Что значит "физический"?* - между программистом и заказчиком находится большой
"слой абстракций". Заказчик описывает логическое поведение программы, а
программист пишет физическую реализацию.

*Кто пишет тесты?* - программист! Могут и другие лица но, кроме прочего,
программист лично заинтересован в автоматизации так как выполняет много раз
один и тот же рабочий цикл *правка* -> *прогон* -> *проверка* -> *правка* -> ...

== Определения и тезисы

- *Код (объект) под тестом* - код который проверяется в ходе теста.
- *Набор тестов* - "Test case", "Test suite", исполняемая программа содержащая
группу тестов. В minitest это экземпляр класса.
- *Тест* - исполняемая программа которая запускает код находящийся под тестом
и запускает проверку результата его выполнения. В minitest это метод экземпляра
класса.
- *Дымовой тест* - подмножество *Тест* но без проверки выполнения.
- *Проверка выполнения* - исполняемая программа проверяющая корректность
исполнения кода под тестом. Делится на два вида - проверка *состояния* и
проверка *поведения*. Подробности далее.
- *Изоляция* - стоит разделить на *изоляцию кода* и *изоляцию тестов*.
Подробности далее.
- *Тест-дублер* - не является тестируемым объектом. Применяется вместо реального
объекта для изоляции кода и (или) проверки поведения. Подробности далее.
- *Тестируемость кода* - свойство текста программы. Код должен быть
"тестируемым" то есть должен быть составлен таким образом, что для него можно
написать несложный набор тестов.

== Граф управления и уровни покрытия кода

[cols=2*a,separator=;]
|===
;Метод `foo()`
[source,ruby,numbered]
----
def foo(a)
  if a <= 5 <1>
    r = '( .. 5]' <2>
  elsif a > 10 <3>
    r = '(10 .. )' <4>
  else <5>
    r = '(5 .. 10]' <6>
  end <7>

  return r <8>
end
----
;Граф управления `foo()`
[svgbob, width=100%, height=100%]
..................................................
            +---------------+
          +-| if a <= 5 (1) |-+
          | +---------------+ |
          |                   |
          V                   V
 +-----------------+     +----------------+
 |r = '( .. 5]' (2)|   +-|elsif a > 10 (3)|-+
 +-----------------+   | +----------------+ |
          |            |                    |
          |            V                    V
          |    +------------------+    +---------+
          |    |r = '(10 .. )' (4)|    | else (5)|
          |    +------------------+    +---------+
          |          |                      |
          |          |             +--------------------+
          |          |             | r = '(5 .. 10]' (6)|
          |          |             +--------------------+
          |          V                      |
          |  +-----------+                  |
          +->| endif (7) |<-----------------+
             +-----------+
                    |
                    V
             +--------------+
             | return r (8) |
             +--------------+
..................................................
|===

.Метод `foo(a)` имеет:
- путей 3
- вариантов значений аргумента `a` - бесконечность
- граничных значений аргумента `a` - два 5 и 10

<<<

Покрытие кода подразумевает оценку степени того насколько подробно тесты
прошли по графу управления и насколько подробно выполнились условные операторы.

.Уровни покрытия согласно https://ru.wikipedia.org/wiki/Покрытие_кода[ru.wikipedia.org]
- покрытие операторов — каждая ли строка исходного кода была выполнена;
- покрытие условий — каждая ли точка решения (вычисления истинно ли или ложно выражение) была выполнена;
- покрытие путей — все ли возможные пути через заданную часть кода были выполнены;
- покрытие функций — каждая ли функция программы была выполнена;
- покрытие вход/выход — все ли вызовы функций и возвраты из них были выполнены.
- покрытие значений параметров — все ли типовые и граничные значения параметров были проверены.

<<<

[cols=2*a,separator=;]
|===
;Граф управления `foo()`
[svgbob, width=100%, height=100%]
..................................................
            +---------------+
          +-| if a <= 5 (1) |-+
          | +---------------+ |
          |                   |
          V                   V
 +-----------------+     +----------------+
 |r = '( .. 5]' (2)|   +-|elsif a > 10 (3)|-+
 +-----------------+   | +----------------+ |
          |            |                    |
          |            V                    V
          |    +------------------+    +---------+
          |    |r = '(10 .. )' (4)|    | else (5)|
          |    +------------------+    +---------+
          |          |                      |
          |          |             +--------------------+
          |          |             | r = '(5 .. 10]' (6)|
          |          |             +--------------------+
          |          V                      |
          |  +-----------+                  |
          +->| endif (7) |<-----------------+
             +-----------+
                    |
                    V
             +--------------+
             | return r (8) |
             +--------------+
..................................................
;Покрытие всех путей графа `foo()` + граничные случаи
[source,ruby,numbered]
----
describe '#foo' do
  it 'when a < 5' do
    foo(4).must_equal '( .. 5]'
  end

  it 'when a == 5' do
    foo(4).must_equal '( .. 5]'
  end

  it 'when a > 10' do
    foo(11).must_equal '(10 .. )'
  end

  it 'when a == 10' do
    foo(10).must_equal '(5 .. 10]'
  end

  it 'when 5 =< a < 10' do
    foo(7).must_equal '(5 .. 10]'
  end
end
----
|===

Для минимального покрытия метода `foo(a)` необходимо 5 тестов для 3-х путей и
двух граничных случаев аргумента `a`. При этом, для значений `a` из диапазонов
можно использовать случайные значения. Так же для значений из диапазонов
можно использовать массивы значений но это вряд ли имеет смысл.

<<<

.Выводы

1. *Утилиты типа `Code Coverage` способны распознать только степень покрытия
операторов*. Более полное покрытие кода лежит на совести программиста и
контролировать это очень сложно или вообще невозможно.
2. *Текст программы (метода) должен быть простым* для того, чтобы программист мог
представить в своей голове граф управления и написать тесты покрывающие все
пути этого графа
3. *Условия в условных операторах должны быть достаточно простыми*
1. *Текст тестов значительно больше текста программы*
3. *Часто невозможно перебрать все возможные значения аргументов и условий*.
Однако всегда надо стараться использовать все граничные случаи т.к. они обычно
считанные.

== Slide FIXME

== Изоляция и тест-дублеры

FIXME

=== Пример полной изоляции

FIXME

== Проверка выполнения

FIXME ассертации, моки

== Нотации тестов

FIXME test_ spec gerkin
